#Intro
As the component diagram of our system shows, our application is divided into three microservices: the Authentication Server, the Board Server, and the Content Server. Each of these is built using the Spring framework: there is a repository which simplifies communication with the database, a service which handles the logic of processing a request, and a controller which calls the service methods and provides API endpoints. Details regarding each of the microservices and how they communicate with each other are outlined below.

#Users
**Responsibility:** The Authentication Server handles all operations and requirements related to users: registration, logging in, and security. Special request classes are used as parameters for methods which handle registration and sign in. After registering, a user can log in using their email and password, which is hashed and matched with an entry in the database, to determine if the login is successful. Afterwards, a randomly generated token is associated with the user while he/she is logged in, and discarded when he/she logs out. To enable this, the UserService interacts with a repository responsible for authentication tokens.

**Role:** In order to communicate with other microservices, the methods of the UserController in the Authentication Microservice return special response objects, which are included in the shared library module of our project. Each microservice knows how to interpret these and determine the identity and role of a user. Likewise, all these other microservices send special request objects, containing a token, to the Authentication Server, which can extract information about a user given this token.

The component diagram of our system shows that the Authentication Server provides an interface for the other two microservices, but does not, at the moment, require any interface. As is described in their corresponding sections, the other two servers send messages to the Authentication Server in order to asses the permissions associated with a user token, and its validity.

**Motivation:** There is a clear distinction between the Authentication Microservice and the other two microservices in our application, namely that users should be separated from the content. Naturally, there are many responsibilities related to users, which are summarized at the beginning of this section, and their number and complexity can only grow as the application becomes more popular and used.

Decoupling the Authentication Server from other microservices also means that different teams can work on different microservices, without having to communicate much with each other. The Board and Content Servers can use the interface provided by this microservice while being unaware of the internal workings of token generation and security.

#Boards
**Responsibility:** As the name suggests, the Board Microservice is responsible for boards. This means that it enables creation, retrieval, and updating of these objects (deletion is omitted, as it is not part of the system requirements). It is also worth mentioning that the parameters passed to the service methods are not in fact instances of the Board class, but of other classes created specifically for requests, which sometimes omit certain details such as the id of the board, or the user who created it, which can be determined in other ways.

**Role:** The responsibilities of this microservice are not only internal. The Board Microservice communicates with other microservices. These relationships are illustrated by the component diagram of our system. 

First of all, we can see that the Board Server requires the interface provided by the Authentication Server. There are some logical reasons behind this. We need to check that a user trying to create or edit a board is a registered user, and that they have permission to do so. In order to do this, the BoardService class uses Springâ€™s RestTemplate to make calls to the Authentication Server. As explained in the section related to the Authentication Server, the responses are objects from the shared module, and they provide information for the Board Microservice to determine if the user is a teacher, or if he/she is the creator of a board. Unsuccessful requests throw exceptions, which are handled by a ControllerAdvice class. An adequate ResponseEntity is returned, containing the error message, or, in case of success, a confirmation, and an HTTP status code. 

Secondly, the Board Microservice provides an interface for the Content Microservice. This consists of one method, which specifies whether a board is locked or not. A board that is locked would no longer allow the creation of threads associated with it. 
 
 **Motivation:** There are many ways to justify the need for a standalone microservice for boards. Unlike threads and posts, which represent the content, boards are mostly used to organize this content depending on its topic. Hence, they are not as tightly coupled as threads and posts, and, while they certainly play an important role in making the forum more readable, an early prototype could be released even if the Board Microservice is not fully implemented. We also thought about future developments of our application, and one that naturally comes to mind is to introduce one more component: courses. It makes sense that each course has multiple boards (perhaps for each lecture, or each week), and the Board Microservice could thus be updated to take on more responsibilities. Had we implemented boards, threads, and posts as one server, this addition would make it overcrowded.

As explained in the section regarding the Authentication Server, it also benefits the maintainability of the system to keep the users in a separate microservice, therefore it is clear why boards and users are separated.

#Threads and posts
**Responsibility:** Threads and Posts represent the Content Microservice. This service enables creation, retrieval and updating of threads and posts. Unauthenticated user is able to only retrieve threads and posts. An authenticated student can retrieve, create and update threads and posts. An authenticated teacher in addition to the operations that students is able to perform, can also lock and unlock threads.

**Role:** Unlike other microservices, Content Microservice communicates with all the rest microservices. From the diagram we see that it requires interfaces to be provided by both Authentication Server and Board Server. This makes Content Microservice to be the most complicated microservice in our project. PostService class actively makes use of ThreadRepository when creating, updating posts and retrieving posts per thread. This indicates that the decision to put Posts and Threads into one microservice was right, as otherwise Posts would have to make requests to Threads over network. Both Threads and Posts use two request (and responses) classes from shared module. One for requests to Boards and one to Authentication. Authentication is needed to validate the user and their actions, in case they want to create or update threads or posts. Boards Microservice is needed to allow creation of threads and posts if the Board is unlocked and prohibit it otherwise.

**Motivation:** The decision to put Threads and Posts together in one microservice seemed logical because in principal a thread is simply a chain of posts. This makes threads and posts tightly coupled. Whereas a board is a storage for threads, hence Boards were implemented in a separate microservice. Though it can be argued that we could have put boards, threads and posts together as they represent the content (which would make the microservice too big and decrease modularity, scalability and make distributed development harder), we definitely had to create a separate Authentication microservice, as it contains everything related to authentication and users and not the content itself. 
